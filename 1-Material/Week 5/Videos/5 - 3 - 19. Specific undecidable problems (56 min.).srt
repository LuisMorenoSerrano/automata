1
00:00:00,650 --> 00:00:03,610
Now were going to see more
undecidable problems.

2
00:00:03,610 --> 00:00:07,590
We begin with Rice's theorem which tells
us that almost every question we can

3
00:00:07,590 --> 00:00:10,887
ask about the recursively enumerable
language is as undecidable.

4
00:00:12,180 --> 00:00:15,160
And we then introduce a problem
called Post's Correspondence Problem.

5
00:00:16,180 --> 00:00:17,780
Which we also show is undecidable.

6
00:00:18,790 --> 00:00:21,660
Post problem does not appear to have
anything to do with Turing machine.

7
00:00:21,660 --> 00:00:25,310
So the fact that we can show it is
undecidable is a valuable step on

8
00:00:25,310 --> 00:00:28,946
our road to it showing
real problems undecidable.

9
00:00:28,946 --> 00:00:34,780
However post problem is still a just a
game but, we can use post problems to show

10
00:00:34,780 --> 00:00:38,639
some real problems, for example questions
about grammars to be undecidable.

11
00:00:39,910 --> 00:00:42,010
Well first, see Rice's theorem.

12
00:00:42,010 --> 00:00:45,700
That theorem involves what
are called properties of languages.

13
00:00:45,700 --> 00:00:49,270
Formally a properly of language
is any set of languages.

14
00:00:49,270 --> 00:00:51,670
The languages that we
say have this property.

15
00:00:51,670 --> 00:00:55,730
For example a property of being infinite
is the set of infinite languages.

16
00:00:55,730 --> 00:00:59,630
The property of being empty is the set
containing only the empty language.

17
00:01:00,840 --> 00:01:03,905
While properties like being
infinite apply to any language,

18
00:01:03,905 --> 00:01:08,440
even not recursively enumerable ones,
we need to represent languages, and

19
00:01:08,440 --> 00:01:12,370
the Turing machine is the most powerful
tool we have for representing languages.

20
00:01:12,370 --> 00:01:18,310
So we'll talk about properties of
recursively and enumerable languages only.

21
00:01:18,310 --> 00:01:22,530
So we should consider our property to
be a problem about Turing machines.

22
00:01:22,530 --> 00:01:26,800
Given a code for Turing machine, does it
define a language with that property?

23
00:01:28,910 --> 00:01:31,680
So for any property p,
we can define a language else of p.

24
00:01:31,680 --> 00:01:34,500
The set of binary strings that

25
00:01:34,500 --> 00:01:38,740
represent a Turing machine whose
language has the property p.

26
00:01:38,740 --> 00:01:41,690
So for example, else of infinite,

27
00:01:45,520 --> 00:01:49,350
is the set of codes of Turing machines
that define an infinite language.

28
00:01:49,350 --> 00:01:55,940
There are two properties we call trivial
for reasons that will be obvious.

29
00:01:55,940 --> 00:01:58,730
For this two properties P,
L sub P is decidable.

30
00:02:00,360 --> 00:02:04,080
One of these trivial properties is
the always false property that contains no

31
00:02:04,080 --> 00:02:06,650
recursively enumerable languages.

32
00:02:06,650 --> 00:02:11,080
We can think of this property as, is not
a recursively a enumerable language.

33
00:02:11,080 --> 00:02:13,565
This property is actually
true of some languages, but

34
00:02:13,565 --> 00:02:17,870
those are outside the recursively
enumerable class obviously, and we're

35
00:02:17,870 --> 00:02:21,960
talking about property only as applied
to the recursive enumerable languages.

36
00:02:24,300 --> 00:02:26,030
How do we deci, decide this property?

37
00:02:27,450 --> 00:02:29,710
Given an input w, ignore it and say no.

38
00:02:31,180 --> 00:02:34,662
Notice that even if w represents
an invalid Turing machine code,

39
00:02:34,662 --> 00:02:38,779
we've agreed to take all those strings
as representing a Turing machine that

40
00:02:38,779 --> 00:02:40,378
accepts the empty language.

41
00:02:40,378 --> 00:02:43,706
But the empty language is
a recursive enumerable language, so

42
00:02:43,706 --> 00:02:47,930
we're correct in saying that w's Turing
machine does not have this property.

43
00:02:50,560 --> 00:02:53,720
The second trivial property
is the always-true property.

44
00:02:53,720 --> 00:02:58,450
We can express the property as,
is a recursively enumerable language.

45
00:02:58,450 --> 00:03:01,970
The algorithm for this property is
to ignore the input and say yes.

46
00:03:04,450 --> 00:03:07,640
And Rice's Theorem says,
for every property P,

47
00:03:07,640 --> 00:03:11,490
except the two trivial ones,
else of P is undecidable.

48
00:03:13,170 --> 00:03:16,470
An important part of the proof of Rice's
Theorem, which we'll be working on for

49
00:03:16,470 --> 00:03:19,550
a while, is the idea of a reduction.

50
00:03:19,550 --> 00:03:22,220
There are actually several
different notions of reduction.

51
00:03:22,220 --> 00:03:24,700
We'll come back to that point later.

52
00:03:24,700 --> 00:03:28,350
But the simplest one, and the one we need
for Rice's theorem is an algorithm that

53
00:03:28,350 --> 00:03:33,130
takes and inputs string w for
one language, or a problem L, and

54
00:03:33,130 --> 00:03:36,520
converts it to another string x that
is an input to another language or

55
00:03:36,520 --> 00:03:42,560
problem L prime, with the property that x
is in L prime if and only if w is in L.

56
00:03:44,700 --> 00:03:48,010
The value of having such a reduction
is that it tells us L is

57
00:03:48,010 --> 00:03:52,680
no harder than L prime, at least as
far as decidability is concerned.

58
00:03:52,680 --> 00:03:55,800
If I know L prime is
recursively enumerable, and

59
00:03:55,800 --> 00:03:57,900
I also have a Turing machine program for
L.

60
00:04:00,120 --> 00:04:05,470
If I know L prime is recursive,
then I also have an algorithm for L.

61
00:04:06,900 --> 00:04:11,860
In either case, the solution for L is to
take the input W, convert it to X, see

62
00:04:11,860 --> 00:04:16,410
what the Turing machine for L prime does,
and take it's output to be at answer 4W.

63
00:04:16,410 --> 00:04:22,400
The thing that turns a string W
into X is called a transducer.

64
00:04:22,400 --> 00:04:26,815
So far we've only talked about a Turing
machine whose output is the yes or

65
00:04:26,815 --> 00:04:32,060
a no that is implied by accepting or
halting without accepting, respectively.

66
00:04:33,770 --> 00:04:37,220
But we can get other kinds of output
from a multi tape Turing machine if we

67
00:04:37,220 --> 00:04:40,260
designate one of its tapes
to be the output tape, and

68
00:04:40,260 --> 00:04:44,110
regard what is written there when
the machine halts as its output.

69
00:04:44,110 --> 00:04:46,646
We could, for example,
imagine such a transduce that takes w

70
00:04:46,646 --> 00:04:51,210
on it's input tape and writes x on
its output tape and then halts.

71
00:04:53,310 --> 00:04:57,140
So if we reduce language L to L prime,
using such a transducer and

72
00:04:57,140 --> 00:05:02,990
L prime is decidable, that is, there is an
algorithm to test membership in L prime,

73
00:05:02,990 --> 00:05:04,640
then there is also an algorithm for L.

74
00:05:06,560 --> 00:05:09,860
That is, we start by applying
the transducer to input w,

75
00:05:09,860 --> 00:05:11,230
and producing output x.

76
00:05:12,980 --> 00:05:16,480
We apply the algorithm for
L prime to input x, and decide whether or

77
00:05:16,480 --> 00:05:18,360
not x is in L prime.

78
00:05:18,360 --> 00:05:22,110
Either way, the algorithm render,
renders a decision, either yes or now.

79
00:05:23,730 --> 00:05:26,470
And these two steps form an algorithm for
L.

80
00:05:26,470 --> 00:05:30,200
The whole thing takes input W and
tells us whether or not W is in L.

81
00:05:34,520 --> 00:05:38,310
We sometimes see a reduction used
to discover an algorithm for L.

82
00:05:38,310 --> 00:05:41,880
But the more important use of
the idea's in the contrapositive.

83
00:05:41,880 --> 00:05:44,010
If we already know that
there is no algorithm for

84
00:05:44,010 --> 00:05:47,300
L, then there cannot be any algorithm for
L prime.

85
00:05:47,300 --> 00:05:49,520
That's how we're going to use reductions.

86
00:05:49,520 --> 00:05:52,360
We'll take one problem that we
may not be interested in, but

87
00:05:52,360 --> 00:05:56,110
that we know in undecidable, and
reduce it to another problem that

88
00:05:56,110 --> 00:06:00,040
we are really interested in, but
whose status we don't yet know.

89
00:06:00,040 --> 00:06:03,120
And then we will conclude that
the second problem is also undecidable.

90
00:06:04,980 --> 00:06:09,080
Moreover, when we get to contractability
of the theory of MP completeness,

91
00:06:09,080 --> 00:06:13,740
we'll be using reductions that are fast to
argue that a problem like L prime can't be

92
00:06:13,740 --> 00:06:15,560
solved faster than the problem L.

93
00:06:18,090 --> 00:06:21,580
There are more powerful forms of reduction
that let us reach the same conclusion,

94
00:06:22,790 --> 00:06:27,390
that is if there is an algorithm for
L prime, then there is an algorithm for L.

95
00:06:29,430 --> 00:06:32,390
We actually saw one example of
a more complex reduction when we

96
00:06:32,390 --> 00:06:34,978
started by assuming there was
an algorithm for L sub U.

97
00:06:34,978 --> 00:06:39,830
The universal language.

98
00:06:39,830 --> 00:06:42,010
And showed how we can then
construct an algorithm for

99
00:06:42,010 --> 00:06:43,670
LD which we know does not exist.

100
00:06:46,590 --> 00:06:49,030
However, the hypothetical
algorithm we construct for

101
00:06:49,030 --> 00:06:53,260
L sub D involve more than just
turning one string into another.

102
00:06:53,260 --> 00:06:56,680
We first have to check whether
the input W is a well-formed coal for

103
00:06:56,680 --> 00:07:00,030
a Turing machine, and
if not we answer the question directly.

104
00:07:01,722 --> 00:07:05,740
Morev, moreover, after doing
a transduction where we turn input W

105
00:07:05,740 --> 00:07:08,920
into W111W,
we had to complement the answer that we

106
00:07:08,920 --> 00:07:13,540
got from the hypothetical algorithm for
L sub U.

107
00:07:13,540 --> 00:07:17,090
That is, we turned a yes
answer into no and vice versa.

108
00:07:17,090 --> 00:07:21,700
In the simple version of reduction, we are
not allowed to modify answers in this way.

109
00:07:21,700 --> 00:07:23,420
We have to take whatever answer we get.

110
00:07:26,500 --> 00:07:29,550
We'll revisit this issue of more
general kinds of reductions when we

111
00:07:29,550 --> 00:07:31,970
talk about empty completeness.

112
00:07:31,970 --> 00:07:35,130
There, the simple reduction
is called a Karp reduction.

113
00:07:35,130 --> 00:07:38,500
And more general kinds of reductions
are called Cook reductions.

114
00:07:38,500 --> 00:07:40,270
Steve Cook and Richard Karp, by the way,

115
00:07:40,270 --> 00:07:44,140
were the people who made the earliest
contributions to NP completeness theory.

116
00:07:45,640 --> 00:07:47,490
We're now ready to prove Rice's theorem.

117
00:07:47,490 --> 00:07:53,632
The idea is that we can reduce L sub U to
L sub P for any nontrivial property P.

118
00:07:53,632 --> 00:07:55,740
Then, since we know L
sub U is undecidable,

119
00:07:55,740 --> 00:07:57,760
it follows that L sub P is undecidable.

120
00:07:59,570 --> 00:08:02,580
Here's how we reduce LU to LP.

121
00:08:02,580 --> 00:08:06,660
The input to LU is a Turing machine M and
an input W for M.

122
00:08:06,660 --> 00:08:10,000
The output will be the code for
Turing machine M prime.

123
00:08:12,330 --> 00:08:16,520
That is at least the right form since
LP is a set of Turing machine codes,

124
00:08:16,520 --> 00:08:19,130
those for which the language
of the machine has property P.

125
00:08:20,800 --> 00:08:25,350
Of course, for the transduction from M and
W to M prime to work,

126
00:08:25,350 --> 00:08:30,020
we must arrange that M prime has
property P if and only if M accepts W.

127
00:08:30,020 --> 00:08:35,380
That is M prime is an L sub P,
if and only if M and W is an L sub U.

128
00:08:37,540 --> 00:08:39,720
We'll design M prime to
be a two tape machine.

129
00:08:41,070 --> 00:08:44,875
On the first tape, M prime simulates
another particular Turing machine which

130
00:08:44,875 --> 00:08:47,820
we'll call M sub L on its own input say X.

131
00:08:49,750 --> 00:08:52,260
On the second tape M
prime simulates M on w.

132
00:08:52,260 --> 00:08:57,270
It is important to understand that
M prime has only it's own input x,

133
00:08:57,270 --> 00:09:00,440
which the transducer does not deal with or
see.

134
00:09:01,570 --> 00:09:06,270
The transducer knows about M sub L, it is
built into the design of the transducer.

135
00:09:08,010 --> 00:09:10,640
The transducer gets to see the code for
M and the string W.

136
00:09:10,640 --> 00:09:12,640
That is on it's own input.

137
00:09:13,930 --> 00:09:18,190
Thus, the transducer can build both
the moves of M and the input W

138
00:09:18,190 --> 00:09:23,840
into the transition function of the
machine M prime that is it's own output.

139
00:09:23,840 --> 00:09:27,379
None of M, M of L or
W is input to M prime.

140
00:09:29,780 --> 00:09:33,300
We're going to assume that the empty
language does not have property P.

141
00:09:33,300 --> 00:09:36,730
If that is not the case,
then consider the complement of P say Q.

142
00:09:38,810 --> 00:09:41,940
Surely, the empty language
then has property Q, but

143
00:09:41,940 --> 00:09:47,460
if we could prove that Q are undecidable,
then P also must be undecidable.

144
00:09:47,460 --> 00:09:50,513
That is if LP were a recursive language,
then so

145
00:09:50,513 --> 00:09:56,700
would be LQ since the classic recursive
languages is closed into complementation.

146
00:09:56,700 --> 00:09:59,850
So, let L be any language with property P.

147
00:09:59,850 --> 00:10:02,100
We know L exists because P is not trivial.

148
00:10:03,190 --> 00:10:06,780
Also, let M sub L be the Turing
machine that accepts L.

149
00:10:09,880 --> 00:10:11,450
Here's how M prime behaves.

150
00:10:13,080 --> 00:10:16,590
To begin,
M primes write w on its second tape.

151
00:10:16,590 --> 00:10:20,390
It can do that because the transducer's
seen w generates a sequence of

152
00:10:20,390 --> 00:10:24,880
states that write w one bit at a time.

153
00:10:24,880 --> 00:10:27,669
M prime, from its start state,
enters each of these states in turn.

154
00:10:28,740 --> 00:10:30,380
Then M prime moves the tape head for

155
00:10:30,380 --> 00:10:35,620
tape 2 to the left end, goes to the start
state of M and simulates w on input w.

156
00:10:36,710 --> 00:10:40,680
Again, M prime can do that because
the transducer sees both M and W and

157
00:10:40,680 --> 00:10:44,890
makes the transition function of M part
of the transition function of M prime.

158
00:10:46,270 --> 00:10:49,480
Suppose during the simulation of M on w,
M enters an accepting state.

159
00:10:50,950 --> 00:10:53,640
Then M prime goes to the start
state of M sub L, and

160
00:10:53,640 --> 00:10:57,120
simulates M sub L on
the input x to M prime.

161
00:10:57,120 --> 00:11:00,510
Which has been just sitting there
on tape one, being ignored so far.

162
00:11:01,720 --> 00:11:05,230
Where does M prime get
the transition function for M sub L?

163
00:11:05,230 --> 00:11:07,320
M sub L has a particular Turing machine,

164
00:11:07,320 --> 00:11:10,520
one that accepts a language
L with property p.

165
00:11:10,520 --> 00:11:14,450
Thus the transducer itself can be designed
so that it writes the transitions of M

166
00:11:14,450 --> 00:11:18,180
sub L out as part of the transition
function of M prime.

167
00:11:20,810 --> 00:11:24,470
If M sub L accepts the input x, then M
prime enters in the accepting state.

168
00:11:25,540 --> 00:11:28,979
If M sub L never accepts x,
neither does M prime.

169
00:11:30,130 --> 00:11:33,050
Thus if M prime ever gets to
the stage where it simulates M,

170
00:11:33,050 --> 00:11:38,690
M sub L, then M prime accepts the same
languages M sub L does, that is L.

171
00:11:38,690 --> 00:11:41,780
But if M does not accept W,
then M prime never gets to

172
00:11:41,780 --> 00:11:45,840
the stage where it simulates M sub L,
and therefore M prime accepts nothing.

173
00:11:47,280 --> 00:11:50,650
Here's a picture to help us
remember what M prime does.

174
00:11:50,650 --> 00:11:52,870
It first simulates M on input w.

175
00:11:53,890 --> 00:11:57,400
So far, M prime's own input x is ignored.

176
00:12:01,190 --> 00:12:07,060
But if M accepts w, then M prime
simulates M sub L on its own input x.

177
00:12:09,320 --> 00:12:12,229
And M prime accepts x if and
only if, x is in L.

178
00:12:14,920 --> 00:12:17,330
So, to summarize what
we know about M prime.

179
00:12:17,330 --> 00:12:18,890
First, suppose M accepts w.

180
00:12:20,380 --> 00:12:24,980
Then M prime simulates M sub L on x,
and accepts x if and only if x is in L.

181
00:12:26,920 --> 00:12:31,070
That is, if M accepts w,
then the language of M prime is L.

182
00:12:31,070 --> 00:12:34,050
We know L has property P,
so M prime is in LP.

183
00:12:36,950 --> 00:12:41,870
Now look at the opposite case
where M does not accept w.

184
00:12:41,870 --> 00:12:44,770
An M prime never even starts
the simulation of ML and

185
00:12:44,770 --> 00:12:47,750
therefore M prime cannot
accept its input x.

186
00:12:49,470 --> 00:12:53,270
That is, in this case, the language
of M prime is the empty language.

187
00:12:53,270 --> 00:12:55,940
We know the empty language
does not have property P.

188
00:12:57,310 --> 00:13:02,440
Thus, if M does not accept w,
M prime is not in the language Lp.

189
00:13:04,850 --> 00:13:07,180
We conclude the algorithm we describe for

190
00:13:07,180 --> 00:13:11,930
converting M and w to M prime
as reduction of L subued to Lp.

191
00:13:11,930 --> 00:13:14,610
And therefore that Lp is undecidable.

192
00:13:14,610 --> 00:13:15,860
That is Rice's theorem.

193
00:13:17,920 --> 00:13:19,970
This is a picture that
reviews the argument for

194
00:13:19,970 --> 00:13:24,790
why the existence of the reduction from
Lu to Lp, proves Lp is undecidable.

195
00:13:25,930 --> 00:13:27,750
We have a real reduction algorithm.

196
00:13:27,750 --> 00:13:30,420
I hope you are convinced that you
could program this algorithm if

197
00:13:30,420 --> 00:13:31,069
you were paid enough.

198
00:13:32,560 --> 00:13:36,640
We then, contradict the hypothesis
that Lp has an algorithm by

199
00:13:36,640 --> 00:13:38,727
supposing that algorithm existed.

200
00:13:40,498 --> 00:13:45,790
Then, you could put together the reduction
plus the hypothetical algorithm to build

201
00:13:45,790 --> 00:13:47,042
an algorithm for Lu.

202
00:13:47,042 --> 00:13:49,800
Since we already proved that
there is no such thing,

203
00:13:49,800 --> 00:13:53,600
we have to look at what,
of this story hasn't been proved.

204
00:13:53,600 --> 00:13:56,180
The finger points at
the hypothetical algorithm for

205
00:13:56,180 --> 00:13:59,550
LP, since we didn't prove it exists,
we just assumed it did.

206
00:14:01,260 --> 00:14:05,690
Thus, the assumption must be responsible
for the false conclusion and

207
00:14:05,690 --> 00:14:09,310
we can conclude instead that there
is no algorithm for property P.

208
00:14:10,360 --> 00:14:13,310
Thanks to Rice's theorem,
we suddenly have an infinite collection of

209
00:14:13,310 --> 00:14:17,260
undecidable problems about the languages
defined by Turing machines.

210
00:14:17,260 --> 00:14:21,040
Here is just a tiny sample of
the questions that are undecidable about

211
00:14:21,040 --> 00:14:21,730
Turing machines M.

212
00:14:23,850 --> 00:14:25,160
Is M's language regular?

213
00:14:26,360 --> 00:14:27,470
Or is it context free?

214
00:14:29,010 --> 00:14:32,050
Does this language include at least
one string that is a palindrome?

215
00:14:32,050 --> 00:14:34,250
That is a string that is
the same as its reversal.

216
00:14:36,580 --> 00:14:37,770
Is the language empty?

217
00:14:37,770 --> 00:14:39,700
That is, does M accept any string at all.

218
00:14:41,320 --> 00:14:43,350
Does the language contain
at least 1,000 strings?

219
00:14:45,380 --> 00:14:49,311
But Rice's theorem also applies to
programs since you can write a program to

220
00:14:49,311 --> 00:14:50,798
simulate a Turing machine.

221
00:14:50,798 --> 00:14:54,730
That tells us any non-trivial
question about what a program does

222
00:14:54,730 --> 00:14:56,382
will also be undecidable.

223
00:14:56,382 --> 00:14:59,981
I want to emphasize about
what a program does.

224
00:14:59,981 --> 00:15:04,490
There are lots of questions about other
program it looks like, that are decidable

225
00:15:04,490 --> 00:15:08,692
for example I can tell whether a program
uses more than 20 variable names.

226
00:15:08,692 --> 00:15:12,470
But that's not a question
about what the program does.

227
00:15:12,470 --> 00:15:15,630
An example of a question
about what a program does,

228
00:15:15,630 --> 00:15:18,829
is does the program eventually hole up,
hope on any input?

229
00:15:19,950 --> 00:15:21,150
That is undecidable.

230
00:15:21,150 --> 00:15:24,300
Or does the program
correctly sort its input?

231
00:15:24,300 --> 00:15:25,960
That's undecidable.

232
00:15:25,960 --> 00:15:28,770
Or does this line of
code ever get executed?

233
00:15:28,770 --> 00:15:29,690
That's undecidable.

234
00:15:31,570 --> 00:15:34,310
We're now going to take
Post's Correspondence Problem,

235
00:15:34,310 --> 00:15:35,814
affectionately known as PCP.

236
00:15:37,960 --> 00:15:41,180
PCP is the first example of
a problem that is undecidable, yet

237
00:15:41,180 --> 00:15:46,960
doesn't involve Turing machines or
programs, which are really the same thing.

238
00:15:46,960 --> 00:15:47,720
As we've said,

239
00:15:47,720 --> 00:15:51,740
PCP is not really important by itself,
since it's just a made up problem.

240
00:15:51,740 --> 00:15:54,459
But it leads us to proofs that many
other problems are undecidable.

241
00:15:55,550 --> 00:15:57,830
These problems are unrelated
to Turing machines, but

242
00:15:57,830 --> 00:16:01,860
are related to matters like context free
languages that were not developed for

243
00:16:01,860 --> 00:16:04,110
the purpose of exposing on
this side of the problems.

244
00:16:05,190 --> 00:16:06,960
That is, we studied grammars for

245
00:16:06,960 --> 00:16:10,710
their use in matters like describing
the structure of programming languages.

246
00:16:10,710 --> 00:16:14,650
We had no intent to describe problems
that turned out to be undecidable.

247
00:16:14,650 --> 00:16:17,540
Just turned out that there were
undecidable problems lurking in

248
00:16:17,540 --> 00:16:19,240
the theory of context free grammars.

249
00:16:20,740 --> 00:16:24,040
An instance of PCP is a list
of corresponding strings.

250
00:16:25,040 --> 00:16:29,010
That is a list of pairs of strings
over some particular alphabet sigma.

251
00:16:31,560 --> 00:16:33,980
The instance has some
number of pairs say N.

252
00:16:35,090 --> 00:16:40,080
The first pair is W1 X1,
the second is W2 X2, and so on.

253
00:16:40,080 --> 00:16:42,460
None of the strings can
be the empty string.

254
00:16:42,460 --> 00:16:47,100
The property of the list that makes
the answer to this instance of PCP be yes,

255
00:16:47,100 --> 00:16:53,900
is that when we take the first component
from each pair on the list that is,

256
00:16:53,900 --> 00:16:59,560
WI1 is actually the first component

257
00:16:59,560 --> 00:17:04,900
of the pair that we indexed as i sub 1,

258
00:17:04,900 --> 00:17:09,220
I can't draw on this slide,
two levels of subscripts.

259
00:17:10,996 --> 00:17:16,960
Then w, the second w i2 is the, that w.

260
00:17:16,960 --> 00:17:21,210
From this list that has, in the,
i that's from the i tooth

261
00:17:22,770 --> 00:17:25,390
pair on that list, and so on.

262
00:17:27,170 --> 00:17:30,890
Then, we get the same string if
we take the W's from the pairs,

263
00:17:30,890 --> 00:17:34,870
as if we took the second components or
the X's from the pairs.

264
00:17:34,870 --> 00:17:37,710
Okay?
Such a list of integers is called

265
00:17:37,710 --> 00:17:39,750
a solution to the instance of PCP.

266
00:17:42,610 --> 00:17:45,030
Here is a simple example instance of PCP.

267
00:17:46,620 --> 00:17:48,000
The alphabet will be 0 and 1.

268
00:17:48,000 --> 00:17:51,570
And there are two pairs.

269
00:17:51,570 --> 00:17:55,234
The first pair is 0 and 01.

270
00:17:56,720 --> 00:18:05,660
The second pair is 100 and 001.

271
00:18:05,660 --> 00:18:12,170
Okay, every time a list of integers has 1,
it refers to this pair.

272
00:18:12,170 --> 00:18:15,815
And every time it has a 2,
it refers to that pair.

273
00:18:15,815 --> 00:18:16,790
Okay?
In this case,

274
00:18:16,790 --> 00:18:19,600
it turns out there is no
solution to this instance of PCP.

275
00:18:21,410 --> 00:18:24,560
The analysis of this simple
instance is not so easy.

276
00:18:24,560 --> 00:18:27,660
The easy part is that no solution
can start with the second pair.

277
00:18:28,700 --> 00:18:31,030
Why?
The reason is that if we choose 2 as

278
00:18:31,030 --> 00:18:36,080
the first integer in
the so-called solution list,

279
00:18:36,080 --> 00:18:40,010
then the first string made from
the W's that are first component.

280
00:18:40,010 --> 00:18:41,140
Will begin with this 1.

281
00:18:41,140 --> 00:18:46,290
But the second string, the one made
from the corresponding xs that

282
00:18:46,290 --> 00:18:50,780
are the second components,
begins with a 0.

283
00:18:50,780 --> 00:18:52,060
I don't care how you continue,

284
00:18:52,060 --> 00:18:56,089
a string that begins with 1 can never
equal a string that begins with a 0.

285
00:18:57,360 --> 00:19:01,730
However, it is possible that the solution
list begins at index 1, because repair 1,

286
00:19:01,730 --> 00:19:03,720
the two strings are not inconsistent.

287
00:19:03,720 --> 00:19:05,650
That is, 1 is a prefix of the other.

288
00:19:06,850 --> 00:19:09,840
So, let's see if we can build a solution
starting with the first pair.

289
00:19:11,468 --> 00:19:15,180
Since the two strings are not equal,
we have to add another pair.

290
00:19:15,180 --> 00:19:16,520
We can't choose pair one,

291
00:19:16,520 --> 00:19:22,090
because the first string would then begin
00 and the second string would begin 01.

292
00:19:22,090 --> 00:19:24,190
That could never lead to a solution.

293
00:19:24,190 --> 00:19:27,590
So, the second index in
the solution must be 2.

294
00:19:27,590 --> 00:19:34,493
Now, both strings begin with 0100, and
the second string has an additional 1.

295
00:19:35,970 --> 00:19:37,960
We're back where we were
at the previous choice.

296
00:19:37,960 --> 00:19:41,790
We can't pick 1 as the third index, but
we can pick 2 and we get a match up to

297
00:19:41,790 --> 00:19:46,850
a point with the second string,
again, having an additional 1.

298
00:19:46,850 --> 00:19:48,410
If you think about it,

299
00:19:48,410 --> 00:19:51,370
we can never make the two strings
be the same, because to do so we

300
00:19:51,370 --> 00:19:55,580
would eventually have to use a pair of the
second string was shorter than the first.

301
00:19:55,580 --> 00:19:58,270
But there is no such
pair in this instance.

302
00:19:58,270 --> 00:20:01,821
We conclude that this
instance has answer no.

303
00:20:01,821 --> 00:20:07,111
On the other hand,
let's change the instance a little

304
00:20:07,111 --> 00:20:11,144
by adding a third pair, 110 and 10.

305
00:20:11,144 --> 00:20:14,969
Now the list of indexes 1,
3 is a solution.

306
00:20:16,020 --> 00:20:23,465
From the first strings with the pairs,

307
00:20:23,465 --> 00:20:28,380
we get 0 followed by 110, which is 0110,

308
00:20:28,380 --> 00:20:33,964
that is 0110 is a 0, followed by a 110.

309
00:20:35,210 --> 00:20:38,150
From the corresponding second strings,
we get 01.

310
00:20:38,150 --> 00:20:42,120
That's this, followed by 10.

311
00:20:42,120 --> 00:20:42,620
That's that.

312
00:20:44,160 --> 00:20:47,150
And that also is 0110.

313
00:20:47,150 --> 00:20:50,603
In fact, there is an infinity
of solutions for this instance.

314
00:20:50,603 --> 00:20:56,214
Any string of index is in the language
on regular expression 12 star 3.

315
00:20:56,214 --> 00:20:57,789
That is, after the one,

316
00:20:57,789 --> 00:21:02,910
we can use pair 2 any number of times,
including zero, obviously.

317
00:21:02,910 --> 00:21:04,380
And finally use the pair three.

318
00:21:05,380 --> 00:21:07,860
So, here's the plan for
proving PCP is undecidable.

319
00:21:09,940 --> 00:21:13,330
We're going to start by introducing
a modified version of the problem called

320
00:21:13,330 --> 00:21:16,350
MPCP, or
the modified post correspondence problem.

321
00:21:16,350 --> 00:21:21,730
The modifications is that a solutions to
MPCP must begin with the first pair, but

322
00:21:21,730 --> 00:21:26,060
otherwise the modified and
original PCP problems are the same.

323
00:21:26,060 --> 00:21:29,650
We'll show how to reduce L sub U,
the universal touring machine language to

324
00:21:29,650 --> 00:21:34,620
MPCP, and
then we'll show how to reduce MPCP to PCP.

325
00:21:34,620 --> 00:21:37,599
In fact,
this part is easier to we'll do it first.

326
00:21:39,180 --> 00:21:43,890
Just to get the distinction
between PCP and MPCP clearer,

327
00:21:43,890 --> 00:21:47,930
observe that if we treat the list of three
pairs, from our previous example of PCP,

328
00:21:47,930 --> 00:21:53,390
as an instance of MPCP,
then the answer is yes.

329
00:21:53,390 --> 00:21:57,850
The reason is that there's a sequence
of indexes beginning with one.

330
00:21:57,850 --> 00:22:03,090
Say, 1 3 that produces equal
strings from the first and

331
00:22:03,090 --> 00:22:04,670
second components of the pairs.

332
00:22:05,860 --> 00:22:09,400
But we can reorder the pairs,
say by putting 110 and 10 first.

333
00:22:09,400 --> 00:22:18,520
As an instance of PCP, order of pairs
doesn't matter, there is still a solution.

334
00:22:18,520 --> 00:22:22,410
But as an instance of MPCP,
there is now no solution.

335
00:22:22,410 --> 00:22:25,230
Any solution would have
to begin with index 1.

336
00:22:25,230 --> 00:22:29,522
But then the first of the two
strings would begin 110, and

337
00:22:29,522 --> 00:22:31,360
the second would begin 10.

338
00:22:31,360 --> 00:22:37,380
So no matter how we extend these strings
they disagree in their second positions.

339
00:22:37,380 --> 00:22:38,800
And so they are not equal.

340
00:22:38,800 --> 00:22:42,201
Before we can talk about reductions,
we need to express PCP and

341
00:22:42,201 --> 00:22:43,585
then MPCP as languages.

342
00:22:43,585 --> 00:22:48,661
[SOUND] The instances of these
problems can have any alphabet.

343
00:22:48,661 --> 00:22:53,128
So, it is not immediately obvious
how to express [SOUND] the set of

344
00:22:53,128 --> 00:22:55,956
all PCP instances that have a solution.

345
00:22:55,956 --> 00:22:59,399
Again, the problem is, is there is
no finite alphabet for this set, and

346
00:22:59,399 --> 00:23:01,550
language is just need
to find that alphabet.

347
00:23:02,630 --> 00:23:05,690
So, we need to code symbols
in a finite alphabet.

348
00:23:05,690 --> 00:23:09,600
We'll represent the odd symbol of
an alphabet by the symbol A followed

349
00:23:09,600 --> 00:23:10,390
by I in binary.

350
00:23:11,470 --> 00:23:15,150
Thus we only need three symbols
to represent any number symbols.

351
00:23:15,150 --> 00:23:17,619
The order of symbols of
the alphabet is not important,.

352
00:23:18,650 --> 00:23:22,480
For example if we have an instance
over alphabet A through Z,

353
00:23:24,030 --> 00:23:31,100
we could represent A by a1,
B by a10 and so on.

354
00:23:32,250 --> 00:23:36,140
But we could also represent Z by a1.

355
00:23:37,530 --> 00:23:42,210
And Y by a10, and so on.

356
00:23:42,210 --> 00:23:44,830
It should be clear that
the particular symbols used for

357
00:23:44,830 --> 00:23:48,380
the alphabet of a PCP instance
does not affect the outcome.

358
00:23:49,430 --> 00:23:53,334
And the only other symbols we need to
represent instances are the comma, and

359
00:23:53,334 --> 00:23:54,864
left and right parentheses.

360
00:23:54,864 --> 00:23:56,236
Thus, the alphabet for

361
00:23:56,236 --> 00:24:00,428
the la, language of PCP instances
will have an alphabet of six symbols.

362
00:24:00,428 --> 00:24:07,321
The a, 0, 1, comma,
left paren, and right paren.

363
00:24:14,841 --> 00:24:16,453
Now that we have a finite alphabet for

364
00:24:16,453 --> 00:24:18,639
coding instances,
we can define two languages.

365
00:24:19,900 --> 00:24:25,370
L sub PCP, the language of coded instances
of PCP that have a solution, and

366
00:24:25,370 --> 00:24:29,540
L sub MPCP is the same for
the modified problem.

367
00:24:29,540 --> 00:24:31,910
Now, we can do the reduction
of MPCP to PCP.

368
00:24:33,130 --> 00:24:35,980
We'll describe the transformation only,
but you should be able to

369
00:24:35,980 --> 00:24:40,630
visualize the process being performed
by a trolling machine transducer.

370
00:24:40,630 --> 00:24:42,340
Our input is an instance of MPCP.

371
00:24:43,690 --> 00:24:48,680
The output instance of PCP will use
the same alphabet as the input instance,

372
00:24:48,680 --> 00:24:52,180
plus two new symbols the star and
the dollar sign.

373
00:24:52,180 --> 00:24:56,860
Of course all symbols, the new ones and
the symbols in the input instance of

374
00:24:56,860 --> 00:25:01,460
MPCP will be coded using a zero's and,
ones as we just described.

375
00:25:02,640 --> 00:25:05,420
For each pair WX in the input instance,

376
00:25:05,420 --> 00:25:09,440
there is a pair in the output
instance based on W and X.

377
00:25:09,440 --> 00:25:14,830
For every first string W of the pair,
we add star after every symbol.

378
00:25:14,830 --> 00:25:18,726
So, for example,

379
00:25:18,726 --> 00:25:25,304
01 becomes 0 star, 1 star.

380
00:25:25,304 --> 00:25:25,876
And for X,

381
00:25:25,876 --> 00:25:30,990
the second string of the pair, we instead
add a star before every character.

382
00:25:30,990 --> 00:25:37,065
So, for example,
11 becomes star 1, star 1.

383
00:25:37,065 --> 00:25:42,916
[SOUND] The output instance also has
a new pair unrelated to any input pair.

384
00:25:42,916 --> 00:25:46,620
This pair is dollar sign
paired with star dollar sign.

385
00:25:47,760 --> 00:25:52,260
And the output also has a second
pair based on the first input pair.

386
00:25:52,260 --> 00:25:55,440
This pair has stars placed after
the symbols of the first string, and

387
00:25:55,440 --> 00:25:57,570
before the symbols of the second string.

388
00:25:57,570 --> 00:26:00,150
Just like in rules one and
two on the slide.

389
00:26:01,380 --> 00:26:04,700
But the first string also
has a star at the beginning.

390
00:26:04,700 --> 00:26:11,724
So, for example, the pair 01,

391
00:26:11,724 --> 00:26:20,686
paired with 0, would become star 0 star,

392
00:26:20,686 --> 00:26:26,520
1 star paired with star 0.

393
00:26:26,520 --> 00:26:28,020
Here's an example.

394
00:26:28,020 --> 00:26:31,420
On the left is the instance of MPCP
that is input to the transducer.

395
00:26:31,420 --> 00:26:35,510
On the right are those
pairs with the added stars.

396
00:26:35,510 --> 00:26:39,140
Notice that for each pair the stars come
after the symbols in the first string,

397
00:26:39,140 --> 00:26:41,560
and before the symbols
in the second string.

398
00:26:43,530 --> 00:26:46,770
And, we always add this pair which
will serve to make the strings of

399
00:26:46,770 --> 00:26:49,860
the PCP instance match, when there
is a solution to the MPCP instance.

400
00:26:50,990 --> 00:26:53,479
It's job is to add the missing
start of the second string.

401
00:26:55,010 --> 00:26:57,650
And this pairs would
come from the first pair.

402
00:26:57,650 --> 00:27:02,300
It is just like the first pair
of the PCP instance, except for

403
00:27:02,300 --> 00:27:05,110
the star at the beginning
of the first sting.

404
00:27:05,110 --> 00:27:11,106
Notice that this is the only pair on
the entire PCP instance where both string

405
00:27:11,106 --> 00:27:16,632
start with the same symbol, for
example, this pair has 0 as the first

406
00:27:16,632 --> 00:27:22,660
symbol of the first string and star as
the first symbol of the second string.

407
00:27:22,660 --> 00:27:24,940
Okay.
All these pairs have second strings that

408
00:27:24,940 --> 00:27:28,176
begin with star and
a first string that begins with 0 or 1.

409
00:27:30,110 --> 00:27:32,840
Suppose the MPCP instance has a solution.

410
00:27:32,840 --> 00:27:36,830
A sequence of indexes that yields string
W, when we use the first strings in

411
00:27:36,830 --> 00:27:39,840
the pairs and same string W
when we use the second strings.

412
00:27:40,970 --> 00:27:44,270
Then we can get a solution to
the destructive PC instance.

413
00:27:44,270 --> 00:27:45,700
In this case,

414
00:27:45,700 --> 00:27:50,680
the solution string will be W padded
with stars before each symbol of W.

415
00:27:50,680 --> 00:27:53,316
And also at the end followed
by the dollar sign.

416
00:27:53,316 --> 00:27:59,319
For example,

417
00:27:59,319 --> 00:28:04,360
if W is 101,
then PCP instances solution is

418
00:28:04,360 --> 00:28:09,860
star 1 star 0 star 1 star dollar sign.

419
00:28:11,210 --> 00:28:14,890
To get the PCP solution,
we use the same sequence of indexes,

420
00:28:14,890 --> 00:28:17,900
as in the solution to the MPCP instance,
with two exceptions.

421
00:28:19,100 --> 00:28:22,840
First, we use the index with
the special pair as the first index.

422
00:28:22,840 --> 00:28:26,980
Recall this pair was constructed from
the first pair of the MPCP instance,

423
00:28:26,980 --> 00:28:28,010
with the extra star.

424
00:28:29,200 --> 00:28:33,930
And we also add to the solution of
the PCP for instance the index of

425
00:28:33,930 --> 00:28:38,990
the ender pair star dollar, and
dollar to the end of the list of indexes.

426
00:28:40,550 --> 00:28:43,840
Thus, a solution to the input
MCP instance means that

427
00:28:43,840 --> 00:28:46,889
the output PCP instance
also has a solution.

428
00:28:48,180 --> 00:28:50,380
But the other direction also holds.

429
00:28:50,380 --> 00:28:54,390
If the PCP instance has a solution,
we can modify it to get a solution for

430
00:28:54,390 --> 00:28:55,447
the input MPCP insta, instance.

431
00:28:58,870 --> 00:29:02,860
The first index in the PCP solution
must be the special pair, because that's

432
00:29:02,860 --> 00:29:07,019
the only pair of the PCP instance where
both strings start with the same symbol.

433
00:29:08,090 --> 00:29:11,895
Change this index to 1, the index of
the first pair of the MPCP index.

434
00:29:11,895 --> 00:29:16,823
[SOUND] Leave all the other
indexes unchanged, but remove from

435
00:29:16,823 --> 00:29:22,377
the PCP solution the last index,
which must be the index of the ender pair.

436
00:29:22,377 --> 00:29:23,340
Why?

437
00:29:23,340 --> 00:29:26,239
That's the only pair where both
strings end with the same symbol.

438
00:29:28,110 --> 00:29:32,780
Thus we've shown that the answer to the
questions, does the input MPCP instance

439
00:29:32,780 --> 00:29:37,980
have a solution and does the output PCP
instance have a solution are the same.

440
00:29:37,980 --> 00:29:41,890
That means we have a valid
reduction from MPCP to PCP.

441
00:29:41,890 --> 00:29:45,130
If we can prove MPCP is undecidable.

442
00:29:45,130 --> 00:29:45,876
Which we'll do next.

443
00:29:45,876 --> 00:29:50,242
And we have a proof that
PCP is also undecidable.

444
00:29:50,242 --> 00:29:55,849
So, our next task is to show
how to reduce L sub U to MPCP.

445
00:29:55,849 --> 00:29:57,688
Given as instance, M and W.

446
00:29:57,688 --> 00:30:01,646
Of l sub u will convert this
to an instance of MPCP,

447
00:30:01,646 --> 00:30:05,704
who's only possible
solutions yield strings that

448
00:30:05,704 --> 00:30:11,103
represent the sequence of ID's that
M enters when it's input is W.

449
00:30:11,103 --> 00:30:15,923
More precisely suppose,
this sequence is a sequence of

450
00:30:15,923 --> 00:30:21,060
ID's that M enters starting
with the initial ID of input W.

451
00:30:23,120 --> 00:30:26,700
Then any solution to the constructed
MPCP instance will yield a pair of

452
00:30:26,700 --> 00:30:30,855
strings that begin with the sequence
of ID's, separated by pound signs.

453
00:30:30,855 --> 00:30:35,748
[SOUND] However,
until M enters an accepting state.

454
00:30:35,748 --> 00:30:40,170
When we look at the 2 strings with the
partial solution, one form from the first

455
00:30:40,170 --> 00:30:44,526
string of the index pairs, and the second
from the second string with the index

456
00:30:44,526 --> 00:30:48,760
pairs, the second string will always
be a full ID ahead of the first string.

457
00:30:48,760 --> 00:30:52,189
Only if M accepts,
will we be able to choose pairs that

458
00:30:52,189 --> 00:30:55,698
make the first string grow
faster than the second, and

459
00:30:55,698 --> 00:30:59,070
eventually make the two
strings become identical.

460
00:31:00,680 --> 00:31:04,710
Were going to assume as we can that
the Turing machine M from the input to L

461
00:31:04,710 --> 00:31:10,390
sub U, has a semi infinite tape and never
moves left from the initial head position.

462
00:31:10,390 --> 00:31:13,360
That is, given the actual
binary string representing M,

463
00:31:13,360 --> 00:31:16,799
we can modify the represented machine
to mark its left hand of tape,.

464
00:31:18,490 --> 00:31:21,530
As we did when we describe
the construction of

465
00:31:21,530 --> 00:31:26,330
a Turing machine with a semi-infinite tape
from one that had a two infinite tape.

466
00:31:26,330 --> 00:31:29,560
Then we can perform the reduction
on the new Turing machine that we

467
00:31:29,560 --> 00:31:32,340
know does the same as M,
rather than on M itself.

468
00:31:33,450 --> 00:31:39,520
However, in what follows, we will continue
to refer to the input machine as M.

469
00:31:39,520 --> 00:31:43,040
The MPCP instance we construct will
have an alphabet that consists of

470
00:31:43,040 --> 00:31:45,510
all the states and tape symbols of M,

471
00:31:45,510 --> 00:31:50,040
or rather the modified M,
plus the special marker pound sign.

472
00:31:50,040 --> 00:31:52,190
We assume the symbol is used for state and

473
00:31:52,190 --> 00:31:56,740
tape symbols at this point, so
we can tell one from another in the ID.

474
00:31:59,730 --> 00:32:03,450
Here's the beginning of the construction
of the MPCP instance from M and W.

475
00:32:03,450 --> 00:32:08,690
The first pair has a first string that is
just a pound sign, but a second string

476
00:32:08,690 --> 00:32:13,100
that is the entire first ID with input W,
surrounded by pound signs,

477
00:32:14,130 --> 00:32:18,450
note that the transducer gets the CW on
its input so it can generate this pair.

478
00:32:21,572 --> 00:32:22,950
Will add the pair pound sign,

479
00:32:22,950 --> 00:32:27,900
pound sign, and let's just add markers
to end of one ID in the first string at

480
00:32:27,900 --> 00:32:31,020
the same time we add it to
the following ID in the second string.

481
00:32:33,880 --> 00:32:37,300
At pair X, X for every tape symbol X.

482
00:32:37,300 --> 00:32:40,880
This pair let's us add an X to the idea
we're forming in the first string at

483
00:32:40,880 --> 00:32:43,630
the same time we add an X to the next ID,

484
00:32:43,630 --> 00:32:45,340
which is being formed
on the second string.

485
00:32:47,390 --> 00:32:50,960
Of course, in order to make sure that
the strings match, it must be the case

486
00:32:50,960 --> 00:32:55,130
that an X appears as the first
unmatched symbol of the second string.

487
00:32:55,130 --> 00:32:57,622
Recall the second string
is one idea ahead, so

488
00:32:57,622 --> 00:33:02,930
these pairs, in effect, let us copy
the tap of one ID to the next ID, but

489
00:33:02,930 --> 00:33:06,170
prevents us from making changes that
are not justified by a move of them.

490
00:33:07,350 --> 00:33:09,000
Here's a picture of copying IDs.

491
00:33:10,560 --> 00:33:13,750
Suppose we have just reached a point
in the sequence of indexes when

492
00:33:13,750 --> 00:33:18,010
the second string has complete ID,
more than the first string, but

493
00:33:18,010 --> 00:33:19,099
otherwise the strings match.

494
00:33:20,490 --> 00:33:23,080
We can add to the solution we're
constructing with pair AA.

495
00:33:23,080 --> 00:33:28,290
That has the effect of putting the first
symbol of the new ID at the end of

496
00:33:28,290 --> 00:33:33,020
the first string, and also extending
the second string by the same symbol.

497
00:33:33,020 --> 00:33:36,490
As for what we want, since there's no
way this A can change in the next ID.

498
00:33:37,830 --> 00:33:41,120
We can also then add the index
of the pair BB to the solution,

499
00:33:41,120 --> 00:33:43,940
extending the new ID one symbol further.

500
00:33:43,940 --> 00:33:47,520
This might or might not be the right
thing to do, the problem is that,

501
00:33:47,520 --> 00:33:52,500
if the move of M and stay Q with symbol C
is to move left, then the second symbol of

502
00:33:52,500 --> 00:33:56,199
the new ID is the new state,
and B will be the third symbol.

503
00:33:57,320 --> 00:34:01,170
But just because we can choose
the pair BB doesn't mean we have to.

504
00:34:01,170 --> 00:34:04,850
If M is going to move left, there will
be another choice of next index that

505
00:34:04,850 --> 00:34:09,590
simulates the move correctly, and
the sequence where BB is chosen instead

506
00:34:09,590 --> 00:34:12,760
will fail to yield a solution to
the MPCP instance we're constructing.

507
00:34:14,750 --> 00:34:17,340
Now we need to add the pairs
that reflect the moves of M.

508
00:34:18,750 --> 00:34:21,380
For every state Q and tape symbol X,

509
00:34:21,380 --> 00:34:26,840
if the move of M is to the right,
say P, Y, R, we

510
00:34:29,490 --> 00:34:34,820
have a pair in which Q
to the left of X that's

511
00:34:36,180 --> 00:34:41,360
this, can be replaced by
a P to the right of Y.

512
00:34:42,600 --> 00:34:47,520
That correctly reflects the change in ID
that occurs in the rightward move, and

513
00:34:47,520 --> 00:34:51,040
if the move is to the left,
then we have a family of pairs, one for

514
00:34:51,040 --> 00:34:53,530
each symbol Z that could appear
to the left of the state.

515
00:34:55,410 --> 00:34:57,060
Note that we arrange.

516
00:34:57,060 --> 00:34:59,570
But M can never move left
from its initial position, so

517
00:34:59,570 --> 00:35:04,060
there's no possibility that the status at
the left end of the ID if M goes left.

518
00:35:06,580 --> 00:35:08,990
So if the leftward move has tape Q and

519
00:35:08,990 --> 00:35:12,420
symbol X, replaced by state P and
symbol Y.

520
00:35:13,440 --> 00:35:19,380
And for every Z, there is a pair that puts

521
00:35:19,380 --> 00:35:25,210
P to the left of the Z, and
replaces the X by the Y.

522
00:35:27,170 --> 00:35:30,580
One other probability is that,
in the current ID, the state is at

523
00:35:30,580 --> 00:35:34,140
the right end of the ID, scanning
a blank we've never visited before.

524
00:35:34,140 --> 00:35:37,892
If so, the state will actually be
to the left of the pound sign.

525
00:35:37,892 --> 00:35:42,925
Okay, and the pairs are almost the same,
but when constructing the second string,

526
00:35:42,925 --> 00:35:46,280
we should imagine an extra blanket
in front of the pound sign.

527
00:35:46,280 --> 00:35:49,430
The bank, blank is replace by
the new symbol Y, of course.

528
00:35:50,830 --> 00:35:56,550
Following our previous example,
suppose that in state Q, scanning C,

529
00:35:56,550 --> 00:36:02,030
M does indeed move right, going to
state P, and writing E in place of C.

530
00:36:05,370 --> 00:36:07,530
Had M moved left in that situation,

531
00:36:07,530 --> 00:36:12,210
the sequence of pair choices would be
dead in the water, unable to continue.

532
00:36:12,210 --> 00:36:15,140
However, in that case, we could
have chosen not to use the pair BB.

533
00:36:16,140 --> 00:36:20,750
But instead use a pair that incorporated
the left move and handled the B properly.

534
00:36:22,100 --> 00:36:25,790
In this case we have a pair
with QC as the first string, so

535
00:36:25,790 --> 00:36:28,500
we can match the string on the bottom.

536
00:36:28,500 --> 00:36:32,730
It also extends the bottom string with EP,
reflecting a move event.

537
00:36:34,160 --> 00:36:38,940
Once the move's been handled,
we can just match symbol against symbol,

538
00:36:38,940 --> 00:36:42,790
here the pair DD is used, and
once we are at the end of the ID,

539
00:36:42,790 --> 00:36:47,492
we use the pair of pound signs to
separate the IDs, and we're now ready to

540
00:36:47,492 --> 00:36:52,460
continue the sequence of pair choices
that copy the new ID, which is ABEpD.

541
00:36:56,740 --> 00:36:58,529
And, make it change by another move.

542
00:37:00,280 --> 00:37:04,510
But we need some more pairs in the MPCP
instance so that in case M accepts,

543
00:37:04,510 --> 00:37:05,700
we can find a solution.

544
00:37:07,500 --> 00:37:12,060
Not that if M never accepts, then only
the rules given so far can ever be used.

545
00:37:12,060 --> 00:37:14,810
And these can never lead to a solution
because the second string is

546
00:37:14,810 --> 00:37:16,960
always one ID longer than the first.

547
00:37:19,030 --> 00:37:24,300
However, if M enters a final state f,
then it is possible for

548
00:37:24,300 --> 00:37:28,010
the f to, we'll say eat
the neighboring symbols of an ID.

549
00:37:30,270 --> 00:37:32,980
We no longer have real IDs of M,
but it doesn't matter.

550
00:37:32,980 --> 00:37:36,650
We've simulated M enough
to know that M accepts W.

551
00:37:36,650 --> 00:37:39,530
And our only concern then is to make
sure that there is a solution to

552
00:37:39,530 --> 00:37:42,820
the MPC instance based on M and W.

553
00:37:44,790 --> 00:37:47,495
Thus we add to the instance of MPCP.

554
00:37:47,495 --> 00:37:53,710
Pairs XfY,f, fY, f, and Xf,

555
00:37:53,710 --> 00:37:59,480
f for all tape symbols X and Y.

556
00:37:59,480 --> 00:38:04,430
Using these pairs to get the pairs of the
form x, x to copy parts of IDs as we have

557
00:38:04,430 --> 00:38:08,330
done, we eventually get to an ID
that is only in the state of f.

558
00:38:08,330 --> 00:38:13,560
Of course, that isn't an actually ID of M,
but it doesn't matter anymore.

559
00:38:13,560 --> 00:38:18,650
And one more pair,
f pound pound paired with the pound sign,

560
00:38:18,650 --> 00:38:21,650
will end the two strings being formed,
making them the same, and

561
00:38:21,650 --> 00:38:24,000
yielding a solution to the MPCP instance.

562
00:38:25,080 --> 00:38:29,660
So, here's an example where M
has entered the final state f.

563
00:38:31,110 --> 00:38:36,540
And a sequence of choices,
either copying a symbol, or allowing

564
00:38:36,540 --> 00:38:41,420
f to eat the adjacent symbol or symbols,
eventually leads to identical strings.

565
00:38:41,420 --> 00:38:42,560
So here's what it looks like.

566
00:38:43,580 --> 00:38:48,550
Well, we'll just have to copy that A,
but now the f can,

567
00:38:48,550 --> 00:38:51,672
in effect, eat the B and C adjacent to it.

568
00:38:52,850 --> 00:38:56,810
We have to copy the D, we have to copy
the E, we have to copy the pound sign.

569
00:38:58,200 --> 00:39:02,890
Now, the f can eat the A and the D, but

570
00:39:02,890 --> 00:39:07,950
we have to copy the E,
have to copy the pound sign.

571
00:39:07,950 --> 00:39:11,290
Now f doesn't have anything that
it can eat to its left, but

572
00:39:11,290 --> 00:39:12,819
it still will eat the E.

573
00:39:14,580 --> 00:39:20,780
And finally, copy the pound sign and

574
00:39:20,780 --> 00:39:26,790
now f pound, pound paired with
pound makes everything evened up.

575
00:39:26,790 --> 00:39:27,940
And we have our solution.

576
00:39:28,970 --> 00:39:32,370
Now we know that PCP is
undecidable because we

577
00:39:32,370 --> 00:39:36,870
successfully reduced l sub u2
to it's own language m sub PCP.

578
00:39:39,400 --> 00:39:41,500
And we're going to reduce
PCP to the problem,

579
00:39:41,500 --> 00:39:43,730
is a context free grammar ambiguous?

580
00:39:45,440 --> 00:39:49,830
Then, for the first time, we'll have a
undecidable problem that arose naturally.

581
00:39:49,830 --> 00:39:53,170
That is, not because we were looking for
undecidable problems.

582
00:39:54,180 --> 00:39:57,020
Before we can talk about any
problem involving grammars,

583
00:39:57,020 --> 00:40:00,670
we need to find a code for
grammars using a finite alphabet.

584
00:40:00,670 --> 00:40:01,990
Just as we did for PCP.

585
00:40:03,210 --> 00:40:04,950
So to start the encoding of grammars,

586
00:40:04,950 --> 00:40:08,600
let's represent the i-th terminal by
symbol a followed by i in binary.

587
00:40:09,610 --> 00:40:15,240
That may look, like we're thus forgetting
what the actual terminal symbols are,

588
00:40:15,240 --> 00:40:19,380
but since we're interested in ambiguity,
we can rename the terminals any way we

589
00:40:19,380 --> 00:40:22,810
like as long as we don't
name two terminals the same.

590
00:40:22,810 --> 00:40:26,890
And the ambiguity or unambiguity
of the grammar will not change.

591
00:40:26,890 --> 00:40:30,580
Then we'll represent the i-th variable
by capital A, followed by i in binary.

592
00:40:32,220 --> 00:40:35,070
We will assume that A1 is
always the start symbol.

593
00:40:37,240 --> 00:40:38,980
The right arrow between the head and

594
00:40:38,980 --> 00:40:41,630
body of a production will
be represented by itself.

595
00:40:42,680 --> 00:40:45,420
Likewise, the comma
separating productions,

596
00:40:45,420 --> 00:40:48,370
and the symbol epsilon
will represent themselves.

597
00:40:50,980 --> 00:40:59,740
For example, this grammar is
represented by this string, right here.

598
00:40:59,740 --> 00:41:02,410
The bar connecting alternative bodies for

599
00:41:02,410 --> 00:41:07,063
S has been expanded, so
that there are two separate productions.

600
00:41:07,063 --> 00:41:15,017
This represents S goes to 0S1.

601
00:41:15,017 --> 00:41:19,640
And this much represents
S goes to capital A.

602
00:41:20,700 --> 00:41:25,110
Finally, this represents
capital A goes to little c.

603
00:41:26,830 --> 00:41:30,780
Suppose we have a PCP
instance with k pairs.

604
00:41:30,780 --> 00:41:33,110
And let the i-th pair be wi, xi.

605
00:41:34,160 --> 00:41:38,680
We need k index symbols to
represent the numbers of the pairs.

606
00:41:38,680 --> 00:41:40,230
And we'll use a1 through ak.

607
00:41:41,260 --> 00:41:45,220
Which we may choose for the symbols that
do not appear in the PCP instance itself.

608
00:41:47,070 --> 00:41:51,910
Notice that we're going to reducing
an uncoated instance of PCP, so

609
00:41:51,910 --> 00:41:57,700
it can have any alphabet to an uncoded
grammar, which also can have any symbols.

610
00:41:57,700 --> 00:42:01,730
However, the process we describe really
takes place with all the symbols coded in

611
00:42:01,730 --> 00:42:03,880
the manners we have described.

612
00:42:03,880 --> 00:42:07,370
It is easier to follow the construction in
the uncoded form, so that's what we'll do.

613
00:42:08,620 --> 00:42:11,850
The, the list language for
the first half of each pair.

614
00:42:11,850 --> 00:42:18,430
The strings w1 through wk, has a context
free grammar with productions.

615
00:42:18,430 --> 00:42:22,590
A goes to wi capital A little ai.

616
00:42:22,590 --> 00:42:28,700
It also has the same sort of production,
that, but with A omitted from the body.

617
00:42:30,010 --> 00:42:34,140
The latter kind of productions, these,
are used to end the derivations.

618
00:42:35,770 --> 00:42:38,990
All the strings in this language
are some sequence of the Wi's with

619
00:42:38,990 --> 00:42:41,830
repetitions allowed and in any order.

620
00:42:41,830 --> 00:42:45,490
With the corresponding index
symbols following, but in reverse.

621
00:42:47,360 --> 00:42:49,975
For example, here's a derivation.

622
00:42:49,975 --> 00:42:57,929
Okay, A could derive in one step,
let's say WiA, little A1.

623
00:43:00,757 --> 00:43:07,686
And then in more one step, we could use,
let's say, the terminal production for w2.

624
00:43:07,686 --> 00:43:12,010
So we get w1, w2 and then a2, a1.

625
00:43:12,010 --> 00:43:17,746
Notice that the sequences of as is
the reverse of the sequence of ws.

626
00:43:19,380 --> 00:43:22,470
And we can do the same thing with
the second string from each pair.

627
00:43:22,470 --> 00:43:27,560
We'll use variable B, and Xi's in place
of Wi's, but the idea is the same.

628
00:43:28,680 --> 00:43:32,840
The language of strings generated from
A and B, each consist of the concatenation

629
00:43:32,840 --> 00:43:38,050
of strings, either from the Wi's if
it's A, or the Xi's for methods B,

630
00:43:38,050 --> 00:43:42,410
and these were the first or
second components with their pairs.

631
00:43:42,410 --> 00:43:46,640
Their followed by the reverse of the
sequences of index of the pairs from which

632
00:43:46,640 --> 00:43:47,520
these strings came.

633
00:43:48,770 --> 00:43:52,050
Here's an example of a PCP
instance over alphabet AB.

634
00:43:54,460 --> 00:43:56,859
We'll use 1, 2, and
3 and the index symbols.

635
00:43:58,260 --> 00:44:01,350
So the grammar with
start symbol A is this.

636
00:44:01,350 --> 00:44:06,770
For example,
the second pair whose first string is baa,

637
00:44:06,770 --> 00:44:08,716
gives rise to these two productions.

638
00:44:08,716 --> 00:44:15,120
Here's baa with the variable a in
the middle and then 2, which is the index,

639
00:44:15,120 --> 00:44:18,760
and then there's another production that
is the same but without the capital A.

640
00:44:20,610 --> 00:44:24,260
And here is the grammar for the second
strings in the pairs, with start symbol B.

641
00:44:24,260 --> 00:44:29,350
'Kay, as an example, if we choose
the three pairs in order 1, 2, 3,

642
00:44:29,350 --> 00:44:34,190
then there is a derivation
from A that looks like this.

643
00:44:35,630 --> 00:44:39,880
So, A, use the first, choice.

644
00:44:39,880 --> 00:44:41,440
That's this production.

645
00:44:43,020 --> 00:44:46,977
Then we'll use the second choice,
which is this production.

646
00:44:46,977 --> 00:44:54,537
And that gives us abaaA21.

647
00:44:54,537 --> 00:44:57,581
And then we'll use the third pair.

648
00:44:57,581 --> 00:45:04,253
But we want to end it, so
we'll use that production,

649
00:45:04,253 --> 00:45:09,571
and that gives us abaabaa, sorry, bba.

650
00:45:09,571 --> 00:45:12,581
That's that.

651
00:45:12,581 --> 00:45:15,427
And then three, two, one.

652
00:45:15,427 --> 00:45:20,680
We're now ready to show how to
reduce PCP to the Ambiguity Problem.

653
00:45:22,600 --> 00:45:26,850
Given a PCP instance, construct the two
list languages, with variables A for

654
00:45:26,850 --> 00:45:29,590
the first strings of the pairs,
and variable B for

655
00:45:29,590 --> 00:45:30,820
the second strings of the pairs.

656
00:45:32,540 --> 00:45:35,280
Then add the productions S goes to A and
S goes to B.

657
00:45:35,280 --> 00:45:37,700
Of course,
S is the start symbol of the grammar.

658
00:45:39,890 --> 00:45:42,270
We'll show the resulting
grammar is ambiguous if and

659
00:45:42,270 --> 00:45:45,020
only if there is a solution
to this instance of PCP.

660
00:45:46,320 --> 00:45:49,890
But first let's look at an example that
should actually expose how the proof in

661
00:45:49,890 --> 00:45:50,535
general works.

662
00:45:50,535 --> 00:45:51,970
Okay.

663
00:45:51,970 --> 00:45:56,220
Here is the grammar constructed from
the PCP instance that we saw earlier.

664
00:45:56,220 --> 00:45:57,980
It is the sects of A products and

665
00:45:57,980 --> 00:46:00,800
B productions we saw,
plus the two productions for S.

666
00:46:01,960 --> 00:46:04,140
Okay.
Notice there is a solution, 1, 3.

667
00:46:04,140 --> 00:46:09,851
That is, the first pair was aab, and

668
00:46:09,851 --> 00:46:14,650
the third pair was bba with ba.

669
00:46:16,240 --> 00:46:22,780
When we take the first strings of each
pair, we get abba, this followed by that,

670
00:46:24,100 --> 00:46:29,940
and when we take the second strings of
each pair, ab and ba, we also get abba.

671
00:46:32,770 --> 00:46:36,570
And this common string followed
by the index string in reverse,

672
00:46:36,570 --> 00:46:42,100
which is that,
will have two leftmost derivations.

673
00:46:42,100 --> 00:46:45,540
One starting with a, and
the other starting with b.

674
00:46:45,540 --> 00:46:49,040
Here is the derivation starting with a.

675
00:46:49,040 --> 00:46:51,750
And here's the derivation starting with b.

676
00:46:51,750 --> 00:46:56,410
So, here's the proof this construction is
a correct reduction from PCP to ambiguity.

677
00:46:57,610 --> 00:47:01,420
First, suppose the PCP instance
has a solution say represented by

678
00:47:01,420 --> 00:47:06,380
the sequence of index symbols a1 through
ak, note there can be repeat in the,

679
00:47:08,380 --> 00:47:12,220
in the sequence, then w1 through wK
is the same string as x1 through xk.

680
00:47:12,220 --> 00:47:15,490
That's what it means for this, for
this index sequence to be a solution,

681
00:47:17,490 --> 00:47:22,100
then the two left most derivations of
the string that is w1 through wk, or

682
00:47:22,100 --> 00:47:23,990
equivalently it's x1 through xk.

683
00:47:25,260 --> 00:47:27,400
That is followed by ak down to a1.

684
00:47:27,400 --> 00:47:32,320
One starts with s, goes to a, and
the other starts with s goes to b.

685
00:47:34,420 --> 00:47:37,220
For the converse, we're going to show
that if there are the two leftmost

686
00:47:37,220 --> 00:47:41,160
derivations of the string of terminals,
then one must begin s goes to a,

687
00:47:41,160 --> 00:47:43,740
the other must begin s goes to b.

688
00:47:45,040 --> 00:47:48,370
Suppose there are two leftmost
derivations that begin with s goes to a.

689
00:47:49,620 --> 00:47:52,840
Then, we can look at the sequence of
index symbols in the resulting terminal

690
00:47:52,840 --> 00:47:54,740
string in reverse.

691
00:47:54,740 --> 00:47:58,140
And learn exactly the sequence
of productions used.

692
00:47:58,140 --> 00:48:01,857
Except for the last production used,
each should be

693
00:48:01,857 --> 00:48:07,522
the unique a production that generates
the index symbol and has an a in the body.

694
00:48:07,522 --> 00:48:12,236
And the final production would
be the one with the last that is

695
00:48:12,236 --> 00:48:15,760
leftmost index symbol,
and no a in the body.

696
00:48:15,760 --> 00:48:19,640
The same idea worked for
derivations that start with s goes to b.

697
00:48:19,640 --> 00:48:22,410
There can be only one with a given
sequence of index symbols.

698
00:48:24,310 --> 00:48:25,750
Here's an example.

699
00:48:25,750 --> 00:48:28,480
If the derivation starts with s goes to a,

700
00:48:28,480 --> 00:48:33,380
and produces a terminal string
with index sequence 2321.

701
00:48:33,380 --> 00:48:36,150
And here's what the derivation
of pars three has to look like.

702
00:48:36,150 --> 00:48:37,620
Okay.

703
00:48:37,620 --> 00:48:38,920
First of all we start with a.

704
00:48:38,920 --> 00:48:44,040
The first production used must
generate the one at the right end.

705
00:48:44,040 --> 00:48:46,600
And we need to keep the a,
so this is the only choice.

706
00:48:46,600 --> 00:48:50,630
So, we've generated w1,
off to the left of the a.

707
00:48:52,280 --> 00:48:57,570
The next index symbol from the right end
is a 2, so we have to use this production

708
00:48:57,570 --> 00:49:02,000
again, we still need to keep that a there,
because we have more index symbols to go.

709
00:49:03,190 --> 00:49:08,220
Then the third from left index symbol is
3, so this is the production we have to

710
00:49:08,220 --> 00:49:14,430
use, and then the last index symbol is 2,
that is the left most index symbol is 2,

711
00:49:14,430 --> 00:49:17,990
so we're going to get rid of that a and
use this production.

712
00:49:17,990 --> 00:49:23,590
That's the only way we can generate
a string with 2321 at the end and

713
00:49:23,590 --> 00:49:28,200
no other index symbols.

714
00:49:28,200 --> 00:49:31,710
We can prove many things about context
free grammars, to be undecided as well.

715
00:49:31,710 --> 00:49:32,710
But to do so,

716
00:49:32,710 --> 00:49:36,560
we need to show that the complement of
a list language is also context free.

717
00:49:37,560 --> 00:49:41,770
Remember that the complement of a context
free language need not be context free.

718
00:49:41,770 --> 00:49:47,040
But fortunately, these are for the proof,
we find it easier to construct the push

719
00:49:47,040 --> 00:49:51,200
down automaton, in fact, a deterministic
push down automaton, for the complement.

720
00:49:52,420 --> 00:49:55,440
The PDA we construct will start
with a bottom marker on its stack.

721
00:49:57,380 --> 00:50:00,360
At first,
some symbols from the PCP instance,

722
00:50:00,360 --> 00:50:03,210
not indexed symbols, will appear.

723
00:50:03,210 --> 00:50:05,340
The PDA simply pushes them onto the stack.

724
00:50:07,850 --> 00:50:10,270
After the first index symbol arrives,

725
00:50:10,270 --> 00:50:13,370
start checking that the proper
strings appear on the stack.

726
00:50:13,370 --> 00:50:16,480
Back.
That is if we see an index symbol ai,

727
00:50:16,480 --> 00:50:20,660
then check that the proper wi appears
on the stack with the right end of wi

728
00:50:20,660 --> 00:50:22,390
at the top.

729
00:50:22,390 --> 00:50:25,320
The PDA pops all the symbols of wi if so.

730
00:50:26,590 --> 00:50:30,180
Note that we're assuming this is the
complement of the list language based on

731
00:50:30,180 --> 00:50:31,650
the first component.

732
00:50:31,650 --> 00:50:34,720
If it is for the second components,
we'll check that xi appears on

733
00:50:34,720 --> 00:50:38,260
the top of the stack again,
with the right end at the top.

734
00:50:38,260 --> 00:50:41,190
What we seem to be doing is
accepting the list language itself,

735
00:50:41,190 --> 00:50:42,420
rather than the complement.

736
00:50:42,420 --> 00:50:44,280
But I didn't tell you
when the PDA accepts.

737
00:50:45,410 --> 00:50:47,810
In fact, it accepts every input,

738
00:50:47,810 --> 00:50:53,240
which only the exception of when it has
found a string in the list language.

739
00:50:53,240 --> 00:50:57,520
That is, if the input so far with some
sequence of PCP symbols followed by

740
00:50:57,520 --> 00:51:01,980
some sequence of index symbols, and
these sequences are not empty, and

741
00:51:01,980 --> 00:51:06,850
the bottom stack marker is now exposed,
then the PDA does not expect this string.

742
00:51:08,450 --> 00:51:11,500
It will accept any other string
that follows which cannot then

743
00:51:11,500 --> 00:51:13,870
also be a solution to the PCP instance.

744
00:51:15,050 --> 00:51:19,450
Now, we can use the complement like let
La and Lb be the list languages for

745
00:51:19,450 --> 00:51:25,510
the first and second components
of an instance of PCP and let

746
00:51:25,510 --> 00:51:28,680
La complement and
Lb complement be their complements.

747
00:51:30,550 --> 00:51:33,720
Now, all four of these languages
are context free languages.

748
00:51:33,720 --> 00:51:37,240
Let's consider the union of
the complement languages.

749
00:51:37,240 --> 00:51:39,080
This is also a context free language,

750
00:51:39,080 --> 00:51:43,028
by the fact that context free
languages are closed under union.

751
00:51:43,028 --> 00:51:47,070
I [INAUDIBLE] about this union
equals sigma star, where sigma is

752
00:51:47,070 --> 00:51:51,620
the alphabet consisting of all the symbols
used by the languages involved, if and

753
00:51:51,620 --> 00:51:54,249
only if there is no solution
to the PCP instance.

754
00:51:55,560 --> 00:51:57,260
Suppose there were a solution?

755
00:51:57,260 --> 00:52:00,790
Say represented by the index
symbols a1 through an,

756
00:52:02,270 --> 00:52:06,860
then this string,
is not in the complement of La,

757
00:52:09,360 --> 00:52:14,530
and the equal string, this,
is not in the complement of b.

758
00:52:16,520 --> 00:52:20,316
Thus, if there's a solution,
there's a string missing from the union.

759
00:52:20,316 --> 00:52:25,461
Conversely, suppose string y,

760
00:52:25,461 --> 00:52:30,612
an down to a1, let's say this.

761
00:52:40,539 --> 00:52:42,070
Is missing from the union.

762
00:52:43,110 --> 00:52:47,538
That means that y is the string you get
by using indexes a1, through an and

763
00:52:47,538 --> 00:52:50,409
taking the first strings
from the index pairs.

764
00:52:50,409 --> 00:52:54,486
And it's also the strong you get by
doing the same with the second pairs.

765
00:52:54,486 --> 00:52:58,340
That means a1 through an is
a solution to the PCP instance.

766
00:52:58,340 --> 00:53:03,130
We have now reduced PCP to the question

767
00:53:04,130 --> 00:53:08,320
is a given context free language equal to
all strings over its terminal alphabet?

768
00:53:10,260 --> 00:53:12,070
Thus this problem is undecidable.

769
00:53:14,240 --> 00:53:15,910
Here's another undecidable question.

770
00:53:15,910 --> 00:53:17,320
About context free language.

771
00:53:18,410 --> 00:53:20,180
Is the language also a regular language?

772
00:53:22,110 --> 00:53:27,150
We do exactly the same reduction from PCP,
and one direction is easy.

773
00:53:27,150 --> 00:53:28,710
If there's no solution,

774
00:53:28,710 --> 00:53:32,730
then we just showed that the union of
the complement language is a sigma star.

775
00:53:33,990 --> 00:53:36,229
And that's surely a regular language.

776
00:53:39,800 --> 00:53:45,800
But, we also need to show the converse,
that if L, the union of the complement

777
00:53:45,800 --> 00:53:49,690
languages is something other than sigma
star, then it's not a regular language.

778
00:53:51,820 --> 00:53:54,600
Suppose we have a solution
to the PCP instance, and

779
00:53:54,600 --> 00:53:58,890
in particular that x be
the index symbols in reverse.

780
00:53:58,890 --> 00:54:01,820
And that gives you the solution and
let w be the string you get

781
00:54:01,820 --> 00:54:04,790
by using the first string from
each of the index pairs in order.

782
00:54:05,950 --> 00:54:10,040
Or obviously equivalently the second
string from the same pairs.

783
00:54:11,560 --> 00:54:14,600
Now let h be the homomorphism
defined by h of 0 is w,

784
00:54:14,600 --> 00:54:19,710
and h of 1 is x, remember,
l is the union of the complements.

785
00:54:19,710 --> 00:54:23,860
The strings that are not solutions
to the given instance of PCP.

786
00:54:25,390 --> 00:54:30,080
We claim that 0 to the n 1 to the n,
is not an L for any n.

787
00:54:30,080 --> 00:54:33,630
Because if we repeat a solution to
a PCP instance any number of times,

788
00:54:34,830 --> 00:54:39,090
we also get solution to that instance.

789
00:54:39,090 --> 00:54:41,640
However, h of y is in L for any other y.

790
00:54:41,640 --> 00:54:43,580
That is, h of y is not a solution.

791
00:54:44,840 --> 00:54:47,310
This point requires a little though.

792
00:54:47,310 --> 00:54:51,030
First, if y isn't zeroes followed by ones,

793
00:54:51,030 --> 00:54:54,260
then h of y isn't of the right
form to be a solution to PCP.

794
00:54:55,290 --> 00:54:59,390
That is, it will not consist of
pcp instance symbols followed by

795
00:54:59,390 --> 00:55:00,270
index symbols.

796
00:55:01,360 --> 00:55:05,550
But if y consists of n ones proceeded
by a different number of zeroes,

797
00:55:05,550 --> 00:55:08,820
then it can't possibly
represent the solution.

798
00:55:08,820 --> 00:55:12,660
H applied to the n ones gives
a particular sequence of index x symbols.

799
00:55:14,250 --> 00:55:17,560
But we know the PCP instance
symbol that this sequence of

800
00:55:17,560 --> 00:55:22,430
index symbols corresponds to
is h applied to n zeroes.

801
00:55:22,430 --> 00:55:25,770
Therefore it couldn't also be h applied
to a different number of zeroes.

802
00:55:26,790 --> 00:55:27,440
So, if L,

803
00:55:27,440 --> 00:55:32,870
the union of compliments were regular,
then h inverse of L would also do regular.

804
00:55:32,870 --> 00:55:36,970
Because regular languages are closed
under inverse homeomorphisms.

805
00:55:36,970 --> 00:55:40,560
And the compliment of h inverse of
L would be regular because regular

806
00:55:40,560 --> 00:55:42,550
languages are closed and
their complementation.

807
00:55:43,550 --> 00:55:47,910
But this language we just argued is
the set of 0 to the N, 1 to the N.

808
00:55:47,910 --> 00:55:50,610
Such that N is at least 1.

809
00:55:50,610 --> 00:55:52,920
A language we know very
well not to be regular.

